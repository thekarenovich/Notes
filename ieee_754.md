### IEEE-754

> Языки программирования с числами с плавающей точкой работает немного не адекватно. 
> Допустим, (0.3 + 0.6) == 0.9 даст False или при сумме 0.4 и 0.3 получим что-то непонятное в виде 0.7000000476837158. Дело не в языке или компьютере, а скорее в самой математике. 
> Как и любое другое число, число с плавающей точкой хранится в памяти компьютера в двоичном виде, а отличается она присутствием точки, для которой нет места среди единиц и нулей. Представить ее в виде цифры нельзя, поэтому здесь нужна какая-то специальная форма хранения, как и в случае с отрицательными числами. Институт IEEE создал стандарт IEEE-754, описывающий способ хранения чисел с плавающей точкой.
> Работает с числом (десятичным) 7.25
> Переводим в двоичную систему счисления. Получили двоичное число 111.01. Стандарт предлагает хранить число в экспоненциальной записи, где S (sign) - знак числа, M(mantis) - дробная часть числа, перед которой всегда идет только одна единица, E(exponenta) - степень основания, которая равняется количеству цифр, на которые точка была смещена относительно своего начального положения. 
> Суть в том, что число нужно подогнать в заданную форму, а чтобы это сделать, нужно точку сдвинуть до тех пор, пока не останется одна единица в начале(слева)
> Значит, 111.01 = 1.1101 * 10^10 (это в 2^2 в двоичной записи)
> ( Для примера еще - 0.0011 = 1.1 * 10^(-11) )
> Для хранения такого числа стандарт предлагает несколько форматов хранения: float(одинарный - 32 бита), double(двойной - 64 бита), long double(расширенный двойной - 80 бит) 
> Кстати, int весит 16 бита, char - 8 бит.
> Рассмотрим формат на 32 бита. Размер памяти разбивается на 3 части, где старший бит - это знак: 0(+), 1(-). А далее нужно понимать, что если целая часть двоичного числа всегда будет равняться единице, потому что мы подгоняем под экс. форму записи, то есть там всегда будет единица, тогда незачем хранить ее в памяти. Сразу к третьей части перейдем, которой отводится 23 бита, где записывается дробная часть, а если остается свободное место справа, то заполняем все нулями, которые никак ни на что тут не влияют. Теперь вторая часть, которой уделяется 8 бит, куда не будем помещать основание степени, то есть не будет хранить в памяти, поскольку оно всегда будет 10 для двоичных чисел, то бишь схожая ситуация с единичкой в целой части числа. Решили хранить, как положительные, так и отрицательные степени, хоть и не отводится еще один бит на знак. Это делается относительно числа 127(десятичное число), то есть взяли 8-битный диапазон чисел от 0 до 255 (число 256(255-0+1) - это 2^8, то есть 256 возможных чисел на 8 бит), в середине которого расположено 127, и сместили степень либо в меньшую, либо в большую сторону относительно этого числа путем сложения степени с этим числом. То есть, если при сложении степени с 127 получается число, меньшее 127, это отрицательная степень, иначе - положительная.
> Значит, 2 (т.е. 10 в дв.с.с.) + 127(десятичное число) = 129 > 127 -> 10000001 - 129 в дв.с.с.
> Кстати, стоит заметить, что доступный диапазон для хранения чисел не 255, а 254, поскольку есть еще специальные значения: в знаке 0, в степени все 1, а дробной части все 0, это бесконечно, а если в знаке не 0, а 1, то минус бесконечность, а если в знаке 1, в степени все 1, а в дробной не все 0, то это NaN(Not a Number), то есть несуществующее число.
> Все. Успешно записали число в память, теперь конвертируем это двоичное число снова в десятичное: 
> 1 + 0.1101 - сложение дробной части с опущенной единицей, которая всегда есть перед мантиссой 
> Эту сумму умножаем на число 10^10, основание которой также опускали при конвертации, а степень мы получаем путем разности степени в двоичном числе и числа 127(10000001 - 1111111) 
> Это произведение умножаем еще на (-1)^0 
> Получаем 111.01 
> Переводим в десятичное число, получаем 7.25
> Получилось все идеально, однако это было одно из удобных непроблемных значений, а если работать другими числами по типу 5.9, то при переводе в двоичное число получим бесконечную периодическую дробь: 101.11100(1100) = 1.0111100(1100) * 10^10. А поместить бесконечность в 23 бита можно лишь путем отсечения части числа, в следствие чего будет возникать неточность, поэтому исходный вид уже не удастся. В 23 бита помещаем столько бит бесконечной дроби, насколько хватает места. А знак и степень считаются точно также, с ними проблем не возникает. Получив двоичное число и переведя его обратно в десятичное, получим уже не 5.9, а 5.89999961.
