O( n ) - цикл for

O ( n^2 ) - вложенный цикл for 

O( log n ) - бинарный поиск 

O( n*log n ) - сортировка

O( 2^n ) - рекурсия 

O( n! ) - поиск кратчайшего пути в графах

O ( 1 ) - одна операция для всех возможных входных данных. Алгоритм выполняется за постоянное/константное время. Вы уже догадались что O(1) алгоритмы самые эффективные.

O( 2n ) -> O( n ) (константы отбрасываем) - два соседних, несвязанных друг с другом, цикла

O( n + n^2 ) -> O( n^2 ) (несущественную часть отбрасываем, т.к. графически даже n^2 растет, куда быстрее, чем n ) - два соседних, несвязанных друг с другом, цикла, один из которые имеет ещё один внутри

O( n^2 + m ) -> O( n^2 + m ) (m не отбросим, ибо ничего про него не знаем) - два соседних, несвязанных друг с другом, цикла, один из которые имеет ещё один внутри, а другой иной индексации



График в файле Graph
